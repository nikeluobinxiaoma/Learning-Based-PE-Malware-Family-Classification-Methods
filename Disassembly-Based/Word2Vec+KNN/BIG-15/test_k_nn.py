import sys
import os
import time

import pickle

from collections import Counter



#alg = int(sys.argv[1])
#win = int(sys.argv[2])
alg = 1
win = 5
fold = 'fold_7'

malware_test_dir = fold + '_test'   # 770 files totally
results_dir = '10-fold-result/' + fold + '/' + fold + '_results_win' + str(win) + '_sg' + str(alg) + '/'
confidence_dir = '10-fold-result/' + fold + '_confidence_win' + str(win) + '_sg' + str(alg) + '/'


# load precalculated distances matrix
with open(fold + '_distances_win' + str(win) + '_sg' + str(alg) + '.pickle', 'rb') as handle:
    distances = pickle.load(handle)
    print('total test cases  =  ' + str(len(distances)))
    print('total distances measured  =  ' + str(len(distances) * len(distances[distances.keys()[0]])))


### define average confidence level dictionary for all values of k
avg_confidences_classic = dict()
avg_confidences_weighted = dict()
for k in {1, 2}:
        avg_confidences_classic[k] = 0.0
        avg_confidences_weighted[k] = 0.0
num_classifications = 0.0


start = time.time()
for root, dirs, filenames in os.walk(malware_test_dir):
        for test_malware in filenames:
                if test_malware not in distances.keys():
                    continue
                if len(distances[test_malware]) == 0:
                    continue



                
                ### no bad test_malware; classification can be made
                num_classifications += 1
                
                ### define closest neighbors dictionaries
                closest_malware = dict()
                closest_distances = dict()
                closest_classes = dict()
                class_score = dict()
                
                ### output file
                out_file = open(results_dir + test_malware, 'a') 
                
                ### array of sorted distances
                sorted_distances = sorted((distances[test_malware]).values())
             #   if test_malware == 'malware_lang_1_131':
             #           print(sorted_distances)

                ### knn classification for different values of k
                for k in {1, 2}:
                        ### define closest neighbors arrays
                        closest_malware[k] = []
                        closest_distances[k] = []
                        closest_classes[k] = []

                        ### knn classification
                        for i in range(0, k):
                                for malware, distance in distances[test_malware].items():
                                        if distance == sorted_distances[i]:
                                                closest_malware[k].append(malware)
                                                closest_distances[k].append(distance)
                                                closest_classes[k].append(malware[malware.index('_') + 6 : malware.index('_') + 7])
                        
                        ### classic kNN
                        counter = Counter(closest_classes[k])
                        closest_class = counter.most_common()[0][0]
                        #out_file.write(str(k) + '_NN classification  =  ' + closest_class + '\n')

                        ### weighted kNN
                        class_score[k] = dict()
                        for mal_class in list(set(closest_classes[k])):
                                class_score[k][mal_class] = 0
                                for index, c in enumerate(closest_classes[k]):
                                        if c == mal_class:
                                                if closest_distances[k][index] == 0:
                                                        closest_distances[k][index] += 0.04
                                                class_score[k][mal_class] += 1.0 / closest_distances[k][index]
                        highest_score = 0
                        closest_class_2 = ''
                        for mal_class in class_score[k]:
                                if class_score[k][mal_class] > highest_score:
                                        highest_score = class_score[k][mal_class]
                                        closest_class_2 = mal_class
                        out_file.write(str(k) + '_NN classification  =  ' + closest_class_2 + '\n')

                        ### confidence computation
                        for closest in closest_classes[k]:
                                if closest == closest_class:
                                        avg_confidences_classic[k] += 1
                                if closest == closest_class_2:
                                        avg_confidences_weighted[k] += 1

for k in {1, 2}:
    avg_confidences_classic[k] = avg_confidences_classic[k] * 100 / (k * num_classifications)
    print('average confidence level, from classic knn where k  =  ' + str(k) + ':  ' + str(avg_confidences_classic[k]))
    avg_confidences_weighted[k] = avg_confidences_weighted[k] * 100 / (k * num_classifications)
    print('average confidence level, from weighted knn where k  =  ' + str(k) + ':  ' + str(avg_confidences_weighted[k]))

end = time.time()
print("predict all test samples with weighted k-NN takes off %.4f s" % (end - start))

